import { type LoaderFunctionArgs, redirect } from "@remix-run/node";
import { randomUUID } from "crypto";
import { sql } from "kysely";
import { z } from "zod";
import { ZGithubUserInfo } from "~/models/github";
import { db, flash, getLogger, UserSession, ZEnv } from "~/util/server";

/**
 * This function validates and reshapes the data returned from the Github API when
 * requesting the user's information.
 */
function parseGithubUserInfo(data: any) {
  const userInfo = ZGithubUserInfo.parse(data);
  return {
    github_id: userInfo.id,
    username: userInfo.login,
    name: userInfo.name,
    avatar_url: userInfo.avatar_url,
    github_url: userInfo.html_url,
  };
}

const ZSearch = z.object({
  /**
   * The OAuth state code stored in the database to prevent CSRF attacks. This was
   * generated by the server in the `/auth/signin/github` route.
   */
  state: z.string(),
  /**
   * The OAuth code returned by Github. This code is used to obtain the user's access
   * token.
   */
  code: z.string(),
});

function errorFlashMessage(id: string) {
  return {
    type: "error",
    title: "Signin Failed",
    message: "Hmm, the request doesn't look to be formed correctly.",
    id,
  };
}

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const logger = getLogger();
  const env = ZEnv.parse(process.env);

  // Ensure Required Search Params
  // -----------------------------------------------------------------------------------
  // The search parameters are required to be present in the URL. If they are not present,
  // then we will redirect the user to the home page.
  let search: z.infer<typeof ZSearch>;
  try {
    logger.info({ traceId: "8ab714de" }, "Validating the search parameters ...");
    const url = new URL(request.url);
    search = ZSearch.parse(Object.fromEntries(url.searchParams.entries()));
    logger.info({ traceId: "43d2b669" }, "Success: Validated the search parameters.");
  } catch (e) {
    logger.warn({ traceId: "0655622f", error: e }, "Failure: Required search params are not present.");
    const globalMessage = errorFlashMessage("a1b2c3d4");
    throw redirect("/", { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
  }

  // Confirm OAuth State Code Matches
  // -----------------------------------------------------------------------------------
  // An OAuth state code is used to prevent CSRF attacks. We need to ensure that the state
  // code that was sent to Github matches the state code that we have stored in our database.

  // retrieve the oauth_state_code from the database
  logger.info({ traceId: "a7a18b53" }, "Retrieving the oauth_state_code from the database ...");
  const stateCode = await db
    .selectFrom("oauth_state_codes")
    .select(["id", "redirect_uri"])
    .where("id", "=", search.state)
    .executeTakeFirstOrThrow()
    .catch(async (e) => {
      logger.info(
        { traceId: "5a1124f6", error: e },
        "Failure: Unable to retrieve the oauth_state_code from the database.",
      );
      const globalMessage = errorFlashMessage("b1c2d3e4");
      throw redirect("/", { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
    });
  logger.info({ traceId: "1f705526" }, "Success: Retrieved the oauth_state_code from the database.");

  // ensure that the state code matches
  logger.info({ traceId: "9d396151" }, "Comparing the state code ...");
  if (stateCode.id !== search.state) {
    logger.info({ traceId: "44c40c44" }, "Failure: The state code does not match.");
    const globalMessage = errorFlashMessage("c3d4e5f6");
    throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
  }
  logger.info({ traceId: "f3b3b3b4" }, "Success: The state code matches.");

  // Request Access Token from Github on Behalf of User
  // -----------------------------------------------------------------------------------
  // We will now request an access token from Github using the "code" from the search
  // params. This access token will allow us to make requests to the Github API on
  // behalf of the user.
  const ZAccessTokenRes = z.object({ access_token: z.string(), scope: z.string(), token_type: z.string() });

  // build the access token request
  const accessTokenUrl = new URL("https://github.com/login/oauth/access_token");
  const accessTokenFormData = new FormData();
  accessTokenFormData.append("client_id", env.GITHUB_CLIENT_ID);
  accessTokenFormData.append("client_secret", env.GITHUB_CLIENT_SECRET);
  accessTokenFormData.append("code", search.code);

  // retrieve the access token
  logger.info({ traceId: "aabd56cc" }, "Requesting the access token from Github ...");
  const { access_token, token_type } = await fetch(accessTokenUrl.toString(), {
    method: "POST",
    body: accessTokenFormData,
    headers: { Accept: "application/json" },
  })
    .catch(async (e) => {
      logger.info({ traceId: "44788db2", error: e }, "Failure: Unable to request the access token from Github.");
      const globalMessage = errorFlashMessage("d5e6f7g8");
      throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
    })
    .then(async (res) => ZAccessTokenRes.parse(await res.json()))
    .catch(async (e) => {
      logger.info({ traceId: "b5e41215", error: e }, "Failure: Unable to parse the access token response from Github.");
      const globalMessage = errorFlashMessage("e6f7g8h9");
      throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
    });
  logger.info({ traceId: "cafac002" }, "Success: Retrieved the access token from Github.");

  // Get User Info from Github
  // -----------------------------------------------------------------------------------
  // We will now use the access token to get the user's information from Github.

  // build the user info request
  let userInfoUrl = new URL("https://api.github.com/user");

  // retrieve the user info
  logger.info({ traceId: "5630973b" }, "Requesting the user info from Github ...");
  const userInfo = await fetch(userInfoUrl.toString(), {
    headers: { Authorization: `${token_type} ${access_token}` },
  })
    .catch(async (e) => {
      logger.info({ traceId: "58925011", error: e }, "Failure: Unable to request the user info from Github.");
      const globalMessage = errorFlashMessage("f7g8h9i0");
      throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
    })
    .then(async (res) => parseGithubUserInfo(await res.json()))
    .catch(async (e) => {
      logger.info({ traceId: "a248df6e", error: e }, "Failure: Unable to parse the user info response from Github.");
      const globalMessage = errorFlashMessage("g8h9i0j1");
      throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
    });
  logger.info({ traceId: "cb1f3f84" }, "Success: Retrieved the user info from Github.");

  // Create or Update the User
  // -----------------------------------------------------------------------------------
  // If the user exists in the database, we will update their information. If the user
  // does not exist, we will create a new user.

  // retrieve the user
  logger.info({ traceId: "e9599102" }, "Retrieving the user from the database ...");
  let user = await db
    .selectFrom("users")
    .select(["id", "name"])
    .where("github_id", "=", userInfo.github_id)
    .executeTakeFirst()
    .catch(async (e) => {
      logger.info({ traceId: "e6545e9a", error: e }, "Failure: Unable to retrieve the user from the database.");
      const globalMessage = errorFlashMessage("h9i0j1k2");
      throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
    });

  // if the user was found, update the user
  if (user !== undefined) {
    logger.info({ traceId: "db4b369e" }, "Success: Retrieved the user from the database.");
    logger.info({ traceId: "9a883097" }, "Updating the user in the database ...");
    const { github_id, ...toUpdate } = userInfo;
    await db
      .updateTable("users")
      .set({ ...toUpdate, modified_at: sql`(datetime('now'))` })
      .where("id", "=", user.id)
      .executeTakeFirstOrThrow()
      .catch(async (e) => {
        logger.error({ traceId: "23d1713b", error: e }, "Failure: Unable to update the user in the database.");
        const globalMessage = errorFlashMessage("i0j1k2l3");
        throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
      });
    logger.info({ traceId: "700fa7dd" }, "Success: Updated the user in the database.");
  } else {
    logger.info({ traceId: "b6f071ed" }, "Failure: Unable to retrieve the user from the database.");
    logger.info({ traceId: "1c3a66f5" }, "Creating the user in the database ...");
    user = await db
      .insertInto("users")
      .values({ id: randomUUID(), ...userInfo })
      .returning(["id", "name"])
      .executeTakeFirstOrThrow()
      .catch(async (e) => {
        logger.error({ traceId: "eb7b695b", error: e }, "Failure: Unable to create the user in the database.");
        const globalMessage = errorFlashMessage("j1k2l3m4");
        throw redirect(stateCode.redirect_uri, { headers: [["Set-Cookie", await flash.serialize({ globalMessage })]] });
      });
    logger.info({ traceId: "76c05211" }, "Success: Created the user in the database.");
  }

  // Create User Session
  // -----------------------------------------------------------------------------------
  logger.info({ traceId: "b1aa51da" }, "Creating the user session in the database ...");
  const sessionCookie = await UserSession.new({ user_id: user.id });
  const flashCookie = await flash.serialize({
    globalMessage: {
      type: "success",
      title: `Hello ${user.name}`,
      message: "You have been signed in successfully.",
      id: "k2l3m4n5",
    },
  });
  logger.info({ traceId: "ea5a6b99" }, "Success: Created the user session in the database.");

  return redirect(stateCode.redirect_uri, {
    headers: [
      ["Set-Cookie", sessionCookie],
      ["Set-Cookie", flashCookie],
    ],
  });
};
