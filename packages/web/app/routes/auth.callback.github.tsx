import { type LoaderFunctionArgs, redirect } from "@remix-run/node";
import { db, getLogger } from "~/util/server";
import { ZEnv } from "~/util";
import { z } from "zod";
import { sql } from "kysely";
import { randomUUID } from "crypto";

/**
 * This function validates and reshapes the data returned from the Github API when
 * requesting the user's information.
 */
function parseGithubUserInfo(data: any) {
  const userInfo = z
    .object({
      login: z.string(),
      id: z.number(),
      name: z.string(),
      avatar_url: z.string(),
      html_url: z.string(),
    })
    .parse(data);
  return {
    github_id: userInfo.id,
    username: userInfo.login,
    name: userInfo.name,
    avatar_url: userInfo.avatar_url,
    github_url: userInfo.html_url,
  };
}

const ZSearch = z.object({
  /**
   * The OAuth state code stored in the database to prevent CSRF attacks. This was
   * generated by the server in the `/auth/signin/github` route.
   */
  state: z.string(),
  /**
   * The OAuth code returned by Github. This code is used to obtain the user's access
   * token.
   */
  code: z.string(),
});

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const logger = getLogger();
  const env = ZEnv.parse(process.env);

  // Ensure Required Search Params
  // -----------------------------------------------------------------------------------
  // The search parameters are required to be present in the URL. If they are not present,
  // then we will redirect the user to the home page.
  let search: z.infer<typeof ZSearch>;
  try {
    logger.info("Validating the search parameters ...");
    const url = new URL(request.url);
    search = ZSearch.parse(Object.fromEntries(url.searchParams));
    logger.info("Success: Validated the search parameters.");
  } catch (e) {
    logger.info(e, "Failure: Required search params are not present.");
    throw redirect("/");
    // TODO: Add a flash message cookie on redirect.
  }

  // Confirm OAuth State Code Matches
  // -----------------------------------------------------------------------------------
  // An OAuth state code is used to prevent CSRF attacks. We need to ensure that the state
  // code that was sent to Github matches the state code that we have stored in our database.

  // retrieve the oauth_state_code from the database
  logger.info("Retrieving the oauth_state_code from the database ...");
  const stateCode = await db
    .selectFrom("oauth_state_codes")
    .select(["id", "redirect_uri"])
    .where("id", "=", search.state)
    .executeTakeFirstOrThrow()
    .catch((e) => {
      logger.info(e, "Failure: Unable to retrieve the oauth_state_code from the database.");
      throw redirect("/");
      // TODO: Add a flash message cookie on redirect.
    });
  logger.info("Success: Retrieved the oauth_state_code from the database.");

  // ensure that the state code matches
  logger.info("Comparing the state code ...");
  if (stateCode.id !== search.state) {
    logger.info("Failure: The state code does not match.");
    throw redirect(stateCode.redirect_uri);
  }

  // Request Access Token from Github on Behalf of User
  // -----------------------------------------------------------------------------------
  // We will now request an access token from Github using the "code" from the search
  // params. This access token will allow us to make requests to the Github API on
  // behalf of the user.
  const ZAccessTokenRes = z.object({ access_token: z.string(), scope: z.string(), token_type: z.string() });

  // build the access token request
  const accessTokenUrl = new URL("https://github.com/login/oauth/access_token");
  const accessTokenFormData = new FormData();
  accessTokenFormData.append("client_id", env.GITHUB_CLIENT_ID);
  accessTokenFormData.append("client_secret", env.GITHUB_CLIENT_SECRET);
  accessTokenFormData.append("code", search.code);

  // retrieve the access token
  logger.info("Requesting the access token from Github ...");
  const { access_token, token_type } = await fetch(accessTokenUrl.toString(), {
    method: "POST",
    body: accessTokenFormData,
    headers: { Accept: "application/json" },
  })
    .catch(async (e) => {
      logger.info(e, "Failure: Unable to request the access token from Github.");
      throw redirect(stateCode.redirect_uri);
      // TODO: Add a flash message cookie on redirect.
    })
    .then(async (res) => ZAccessTokenRes.parse(await res.json()))
    .catch(async (e) => {
      logger.info(e, "Failure: Unable to parse the access token response from Github.");
      throw redirect(stateCode.redirect_uri);
    });
  logger.info("Success: Retrieved the access token from Github.");

  // Get User Info from Github
  // -----------------------------------------------------------------------------------
  // We will now use the access token to get the user's information from Github.

  // build the user info request
  let userInfoUrl = new URL("https://api.github.com/user");

  // retrieve the user info
  logger.info("Requesting the user info from Github ...");
  const userInfo = await fetch(userInfoUrl.toString(), {
    headers: { Authorization: `${token_type} ${access_token}` },
  })
    .catch(async (e) => {
      logger.info(e, "Failure: Unable to request the user info from Github.");
      throw redirect(stateCode.redirect_uri);
      // TODO: Add a flash message cookie on redirect.
    })
    .then(async (res) => parseGithubUserInfo(await res.json()))
    .catch(async (e) => {
      logger.info(e, "Failure: Unable to parse the user info response from Github.");
      throw redirect(stateCode.redirect_uri);
      // TODO: Add a flash message cookie on redirect.
    });
  logger.info("Success: Retrieved the user info from Github.");

  // Create or Update the User
  // -----------------------------------------------------------------------------------
  // If the user exists in the database, we will update their information. If the user
  // does not exist, we will create a new user.

  // retrieve the user
  logger.info("Retrieving the user from the database ...");
  let user = await db
    .selectFrom("users")
    .select(["id"])
    .where("github_id", "=", userInfo.github_id)
    .executeTakeFirst()
    .catch((e) => {
      logger.info(e, "Failure: Unable to retrieve the user from the database.");
      throw redirect(stateCode.redirect_uri);
      // TODO: Add a flash message cookie on redirect.
    });

  // if the user was found, update the user
  if (user !== undefined) {
    logger.info("Success: Retrieved the user from the database.");
    logger.info("Updating the user in the database ...");
    const { github_id, ...toUpdate } = userInfo;
    await db
      .updateTable("users")
      .set({ ...toUpdate, modified_at: sql`(datetime('now'))` })
      .where("id", "=", user.id)
      .executeTakeFirstOrThrow()
      .catch((e) => {
        logger.error(e, "Failure: Unable to update the user in the database.");
        throw redirect(stateCode.redirect_uri);
        // TODO: Add a flash message cookie on redirect.
      });
    logger.info("Success: Updated the user in the database.");
  } else {
    logger.info("Failure: Unable to retrieve the user from the database.");
    logger.info("Creating the user in the database ...");
    user = await db
      .insertInto("users")
      .values({ id: randomUUID(), ...userInfo })
      .returning("id")
      .executeTakeFirstOrThrow()
      .catch((e) => {
        logger.error(e, "Failure: Unable to create the user in the database.");
        throw redirect(stateCode.redirect_uri);
        // TODO: Add a flash message cookie on redirect.
      });
    logger.info("Success: Created the user in the database.");
  }

  // Retrieve User Roles
  // -----------------------------------------------------------------------------------
  // We will now retrieve the roles that are associated with the user. Each session will
  // have an array of the user's roles associated with it.
  logger.info("Retrieving the user's roles from the database ...");
  const roles = await db
    .selectFrom("user_roles")
    .select(["role_id"])
    .where("user_id", "=", user.id)
    .execute()
    .catch((e) => {
      logger.error(e, "Failure: Unable to retrieve the user's roles from the database.");
      throw redirect(stateCode.redirect_uri);
      // TODO: Add a flash message cookie on redirect.
    });

  // Create User Session
  // -----------------------------------------------------------------------------------
  logger.info("Creating the user session in the database ...");
  const session = await db
    .insertInto("sessions")
    .values({ id: randomUUID(), user_id: user.id, roles: JSON.stringify(roles.map((r) => r.role_id)) })
    .returningAll()
    .executeTakeFirstOrThrow()
    .catch((e) => {
      logger.error(e, "Failure: Unable to create the user session in the database.");
      throw redirect(stateCode.redirect_uri);
      // TODO: Add a flash message cookie on redirect.
    });
};
